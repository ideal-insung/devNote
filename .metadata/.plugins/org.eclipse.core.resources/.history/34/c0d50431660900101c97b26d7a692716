package algorithm;

/*
UnionFind 알고리즘 선행학습 필요
해당 배열의 대표값을 인덱스가 가장 작은값으로 수정(연결이 되어있다면 그래프가)
 
*/
public class MST {
   
	int prvNum[];
	
	class Edge{
		int x;    //1번노드
		int y;    //2번노드
		int cost; //비용
		public Edge(int x, int y, int cost) {
			this.x= x;
			this.y= y;
			this.cost= cost;
		}
	}
	
	public MST(int size) { //배열값에 인덱스만 큼의 값을 초기화
		prvNum = new int[size+1];
		for(int i =1; i<size+1;i++) {
			prvNum[i] = i;
		}
	}
	
	
	public void union(int x, int y) {
		x = find(x);
		y = find(y);
		if(x < y) { //기준을 x로 잡게된다면
			prvNum[y] = x;
		}else {
			prvNum[x] = y; 
		}
	}
	
	public int find(int x) {
		if(prvNum[x] == x) return x;
		else return prvNum[x] = find(prvNum[x]);
	}
	
	public boolean isConnect(int x, int y) {
		x = find(x);
		y = find(y);
		if(x == y) return true;
		else return false;
	}
}
