package data_structure;

import java.util.Scanner;

public class binarySearchTree {

	private static Node root; //rootNode
	
	public static void show() {
		System.out.println("오름순회:");
		leftInorder(root);
		System.out.println();
	}
	
	public static void leftInorder(Node node) {
		if(node == null) return;
		leftInorder(node.getLeft());
		System.out.println(node.getVal());
		leftInorder(node.getRight());
	}
	
	public static Node search(Node root, int number) {
		if(root == null) return null;
		if(number == root.getVal()) { //찾고자 하는 값이 root에 있다면,
			return root;
		}else if(number < root.getVal()) { //루트의 값이 더크다면
			return search(root.getLeft(), number);
		}else if(number > root.getVal()) { //루트의 값이 더 작다면
			return search(root.getRight(), number);
		}
	}
	
	public static void add(binarySearchTree bst , Scanner sc) {
		System.out.println("값을 몇번 넣으시겠습니까?");
		int cnt = sc.nextInt();
		System.out.println(cnt+"번 넣을게요!");
		for(int i=1; i<=cnt;i++) {
			bst.addNode(sc.nextInt());
			sc.nextLine();
		}
		System.out.println("add complete!");
	}
	
	public Node delete(Node root, int number) {
		if(root == null) return null;
		if(number <root.getVal()) {
			if(root.getLeft() == null) System.out.println(number+"값이 없습니다!");
			else root.setLeft(delete(root.getLeft(), number));
		}else if(number > root.getVal()) {
			if(root.getRight() == null) System.out.println(number+"값이 없습니다!");
			else root.setRight(delete(root.getRight(), number));
		}else {
			if(root.getLeft() == null && root.getRight() == null) return null;
			else if(root.getLeft() == null) return root.getRight();
			else if(root.getRight() == null) return root.getLeft();
			
			root.setVal(findMax(root.getRight()),number);
			root.setRight(delete(root.getRight(), root.getVal()));
		}
		return root;
	}
	
	public static Node findMax(Node root) {
		if(root == null) return null;
		if(root.getRight() != null) {
			return findMax(root.getRight());
		}
		return root;
	}
	
	public static Node findMini(Node root) {
		if(root == null) return null;
		if(root.getLeft() != null) {
			return findMax(root.getLeft());
		}
		return root;
	}
	
	public static void addNode(int val) {
		Node newNode = new Node(val);
		if(root == null) { //root가 null이면  객체생성
			root = newNode;
			return;
		}
		
		Node currntNode = root;
		Node parentNode = null;
		
		while(true) {
			parentNode = currntNode ;
			if( val > parentNode.getVal()) { // val값이 현재 parentNode보다 크다면, 왼쪽으로 가지를 뻗어나가야 한다
				parentNode = parentNode.getLeft();
				if(currntNode == null) {//null == >  마지막요소
					parentNode.setLeft(newNode); //부모의 left에 셋팅
					return;
				}else if(currntNode.getVal() == newNode.getVal()) { //값이 같다면 리턴
					return;
				}
			}else if(val <= parentNode.getVal()) { // val값이 현재 parentNode보다 크다면, 오른쪽으로 가지를 뻗어나가야 한다
				parentNode = parentNode.getRight();
				if(currntNode == null) { //null == >  마지막요소
					parentNode.setRight(newNode); //부모의 right에 셋팅
					return;
				}else if(currntNode.getVal() == newNode.getVal()) {//값이 같다면 리턴
					return;
				}
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("1 - add ");
		System.out.println("2 - delete");
		System.out.println("3 - search");
		System.out.println("4 - maximum");
		System.out.println("5 - minimum");
		System.out.println("6 - inorderShow");

		switch (sc.nextInt()) {
		case 1:
			System.out.println("값을 몇번 넣으시겠습니까?");
			int cnt = sc.nextInt();
			binarySearchTree bts = new binarySearchTree();
			for(int i=1;i<=cnt;i++) {
				bts.addNode(sc.nextInt());
				sc.nextLine();
			}
			sc.close();
			//bts.show();
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;

		default:
			break;
		}
	}
}
